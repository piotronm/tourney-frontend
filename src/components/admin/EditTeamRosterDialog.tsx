import type { FC } from 'react';
import { useState, useMemo, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  Typography,
  Alert,
  Chip,
  Avatar,
  IconButton,
  FormControlLabel,
  Switch,
  TextField,
  CircularProgress,
  Divider,
} from '@mui/material';
import { Close as CloseIcon, SwapVert as SwapIcon } from '@mui/icons-material';
import { PlayerAutocomplete } from '@/components/common/PlayerAutocomplete';
import { useUpdateTeamRoster } from '@/hooks/admin/useUpdateTeamRoster';
import { useRegistrations } from '@/hooks/admin/useRegistrations';
import type { Player } from '@/types/player';
import type { Team } from '@/types/team';
import {
  getInitials,
  generateTeamName,
  getCombinedDupr,
  formatDuprRating,
} from '@/utils/formatters';

interface EditTeamRosterDialogProps {
  open: boolean;
  onClose: () => void;
  team: Team;
  tournamentId: number;
  divisionId: number;
}

export const EditTeamRosterDialog: FC<EditTeamRosterDialogProps> = ({
  open,
  onClose,
  team,
  tournamentId,
  divisionId,
}) => {
  const [player1, setPlayer1] = useState<Player | null>(null);
  const [player2, setPlayer2] = useState<Player | null>(null);
  const [customName, setCustomName] = useState('');
  const [regenerateName, setRegenerateName] = useState(false);

  const { data: registrationsData, isLoading: loadingRegistrations } = useRegistrations(
    tournamentId,
    { divisionId }
  );

  const { mutate: updateRoster, isPending, error } = useUpdateTeamRoster(
    tournamentId,
    divisionId,
    team.id
  );

  // Initialize form with current team players
  useEffect(() => {
    if (open && team.players) {
      const sortedPlayers = [...team.players].sort((a, b) => a.position - b.position);

      if (sortedPlayers[0]) {
        setPlayer1({
          id: sortedPlayers[0].id,
          name: sortedPlayers[0].name,
          email: null,
          duprId: null,
          singlesRating: sortedPlayers[0].singlesRating,
          doublesRating: sortedPlayers[0].doublesRating,
          duprRating: sortedPlayers[0].duprRating,
          phone: null,
          duprRatingUpdatedAt: null,
          createdAt: '',
          updatedAt: '',
        });
      }

      if (sortedPlayers[1]) {
        setPlayer2({
          id: sortedPlayers[1].id,
          name: sortedPlayers[1].name,
          email: null,
          duprId: null,
          singlesRating: sortedPlayers[1].singlesRating,
          doublesRating: sortedPlayers[1].doublesRating,
          duprRating: sortedPlayers[1].duprRating,
          phone: null,
          duprRatingUpdatedAt: null,
          createdAt: '',
          updatedAt: '',
        });
      } else {
        setPlayer2(null);
      }

      setCustomName(team.name);
      setRegenerateName(false);
    }
  }, [open, team]);

  // Get available players (registered without teams, plus current team's players)
  const availablePlayers = useMemo(() => {
    if (!registrationsData?.data) return [];

    const divisionIdNum = Number(divisionId);
    const playersMap = new Map<number, Player>();

    registrationsData.data.forEach((registration: any) => {
      // Check if player is assigned to this specific division
      const divisionAssignment = registration.divisions?.find(
        (div: any) => div.divisionId === divisionIdNum
      );

      if (!divisionAssignment) {
        return; // Not in this division
      }

      // CRITICAL FIX: Include players on THIS team OR no team
      // Check if this player is on the current team being edited
      const isOnCurrentTeam = team.players?.some(p => p.id === registration.playerId);
      const isOnOtherTeam = divisionAssignment.teamId !== null && !isOnCurrentTeam;

      if (isOnOtherTeam) {
        return; // Skip - on a different team
      }

      // Include this player (either no team or on current team)
      const player: Player = {
        id: registration.playerId,
        name: registration.playerName,
        email: registration.playerEmail || null,
        duprId: registration.playerDuprId || null,
        singlesRating: null,
        doublesRating: registration.playerDuprRating,
        duprRating: registration.playerDuprRating,
        phone: null,
        duprRatingUpdatedAt: null,
        createdAt: '',
        updatedAt: '',
      };

      playersMap.set(player.id, player);
    });

    return Array.from(playersMap.values());
  }, [registrationsData, team, divisionId]);

  // Auto-generate team name from selected players
  const autoGeneratedName = useMemo(() => {
    if (!player1) return '';
    if (!player2) return player1.name;
    return generateTeamName(player1.name, player2.name);
  }, [player1, player2]);

  // Calculate combined DUPR
  const combinedDupr = useMemo(() => {
    const players = [player1, player2].filter(Boolean) as Player[];
    if (players.length === 0) return 0;
    return getCombinedDupr(players);
  }, [player1, player2]);

  // Detect if changes were made
  const hasChanges = useMemo(() => {
    const currentPlayerIds = team.players?.map(p => p.id).sort() || [];
    const newPlayerIds = [player1?.id, player2?.id].filter(Boolean).sort() as number[];

    const playersChanged = JSON.stringify(currentPlayerIds) !== JSON.stringify(newPlayerIds);
    const nameChanged = regenerateName || (customName !== team.name);

    return playersChanged || nameChanged;
  }, [player1, player2, team, regenerateName, customName]);

  const handleSubmit = () => {
    if (!player1) return;

    const playerIds = [player1.id];
    if (player2) playerIds.push(player2.id);

    const requestData: {
      playerIds: number[];
      name?: string;
      regenerateName?: boolean;
    } = {
      playerIds,
    };

    if (regenerateName) {
      requestData.regenerateName = true;
    } else if (customName && customName !== team.name) {
      requestData.name = customName;
    }

    updateRoster(requestData, {
      onSuccess: () => {
        handleClose();
      },
    });
  };

  const handleClose = () => {
    if (!isPending) {
      setPlayer1(null);
      setPlayer2(null);
      setCustomName('');
      setRegenerateName(false);
      onClose();
    }
  };

  const handleSwapPlayers = () => {
    const temp = player1;
    setPlayer1(player2);
    setPlayer2(temp);
  };

  const teamNameToUse = regenerateName ? autoGeneratedName : customName;
  const canSubmit = player1 !== null && !isPending && hasChanges;

  return (
    <Dialog
      open={open}
      onClose={handleClose}
      maxWidth="sm"
      fullWidth
      disableEscapeKeyDown={isPending}
    >
      <DialogTitle>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Typography variant="h6">Edit Team Roster</Typography>
          <IconButton onClick={handleClose} disabled={isPending} size="small">
            <CloseIcon />
          </IconButton>
        </Box>
      </DialogTitle>

      <DialogContent>
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3, pt: 1 }}>
          {/* Current Team Info */}
          <Alert severity="info">
            Editing roster for: <strong>{team.name}</strong>
          </Alert>

          {/* Loading State */}
          {loadingRegistrations && (
            <Box sx={{ display: 'flex', justifyContent: 'center', py: 2 }}>
              <CircularProgress size={32} />
            </Box>
          )}

          {/* No Available Players Warning */}
          {!loadingRegistrations && availablePlayers.length === 0 && (
            <Alert severity="warning">
              No players available. All registered players are already on other teams.
            </Alert>
          )}

          {/* Player Selection */}
          {!loadingRegistrations && availablePlayers.length > 0 && (
            <>
              <Box>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                  <Typography variant="subtitle2">
                    Player 1 (Required)
                  </Typography>
                  {player1 && player2 && (
                    <IconButton
                      size="small"
                      onClick={handleSwapPlayers}
                      disabled={isPending}
                      title="Swap player positions"
                    >
                      <SwapIcon fontSize="small" />
                    </IconButton>
                  )}
                </Box>
                <PlayerAutocomplete
                  players={availablePlayers}
                  value={player1}
                  onChange={setPlayer1}
                  label="Select Player"
                  placeholder="Search by name..."
                  disabled={isPending}
                  excludePlayerIds={player2 ? [player2.id] : []}
                />
              </Box>

              <Box>
                <Typography variant="subtitle2" gutterBottom>
                  Player 2 (Optional - for doubles)
                </Typography>
                <PlayerAutocomplete
                  players={availablePlayers}
                  value={player2}
                  onChange={setPlayer2}
                  label="Select Partner"
                  placeholder="Leave empty for solo team..."
                  disabled={!player1 || isPending}
                  excludePlayerIds={player1 ? [player1.id] : []}
                />
              </Box>
            </>
          )}

          {/* Selected Players Preview */}
          {player1 && (
            <>
              <Divider />

              <Box>
                <Typography variant="subtitle2" gutterBottom>
                  Updated Roster
                </Typography>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1.5 }}>
                  {/* Player 1 */}
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Avatar sx={{ width: 32, height: 32 }}>
                      {getInitials(player1.name)}
                    </Avatar>
                    <Box sx={{ flex: 1 }}>
                      <Typography variant="body2" fontWeight={500}>
                        {player1.name}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        Position 1
                      </Typography>
                    </Box>
                    {player1.doublesRating && (
                      <Chip
                        label={formatDuprRating(player1.doublesRating)}
                        size="small"
                        variant="outlined"
                      />
                    )}
                  </Box>

                  {/* Player 2 */}
                  {player2 && (
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                      <Avatar sx={{ width: 32, height: 32, bgcolor: 'secondary.main' }}>
                        {getInitials(player2.name)}
                      </Avatar>
                      <Box sx={{ flex: 1 }}>
                        <Typography variant="body2" fontWeight={500}>
                          {player2.name}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          Position 2
                        </Typography>
                      </Box>
                      {player2.doublesRating && (
                        <Chip
                          label={formatDuprRating(player2.doublesRating)}
                          size="small"
                          variant="outlined"
                        />
                      )}
                    </Box>
                  )}
                </Box>

                {/* Combined DUPR */}
                {combinedDupr > 0 && (
                  <Box sx={{ mt: 2, pt: 2, borderTop: '1px solid', borderColor: 'divider' }}>
                    <Typography variant="body2" color="text.secondary">
                      Combined DUPR:{' '}
                      <Typography component="span" variant="body2" fontWeight={600} color="primary">
                        {formatDuprRating(combinedDupr)}
                      </Typography>
                    </Typography>
                  </Box>
                )}
              </Box>
            </>
          )}

          {/* Team Name Section */}
          {player1 && (
            <>
              <Divider />

              <Box>
                <FormControlLabel
                  control={
                    <Switch
                      checked={regenerateName}
                      onChange={(e) => setRegenerateName(e.target.checked)}
                      disabled={isPending}
                    />
                  }
                  label="Regenerate team name from players"
                />

                {regenerateName ? (
                  <Alert severity="info" sx={{ mt: 1 }}>
                    New team name: <strong>{autoGeneratedName}</strong>
                  </Alert>
                ) : (
                  <TextField
                    fullWidth
                    label="Team Name"
                    value={customName}
                    onChange={(e) => setCustomName(e.target.value)}
                    disabled={isPending}
                    sx={{ mt: 1 }}
                    helperText="Keep current name or enter a new one"
                  />
                )}
              </Box>
            </>
          )}

          {/* No Changes Warning */}
          {!hasChanges && player1 && (
            <Alert severity="info">
              No changes detected. Roster and name are the same.
            </Alert>
          )}

          {/* Error Display */}
          {error && (
            <Alert severity="error">
              {(error as any).response?.data?.message ||
               (error as any).response?.data?.error ||
               'Failed to update team roster. Please try again.'}
            </Alert>
          )}
        </Box>
      </DialogContent>

      <DialogActions sx={{ px: 3, pb: 2 }}>
        <Button onClick={handleClose} disabled={isPending}>
          Cancel
        </Button>
        <Button
          variant="contained"
          onClick={handleSubmit}
          disabled={!canSubmit}
        >
          {isPending ? 'Saving Changes...' : 'Save Changes'}
        </Button>
      </DialogActions>
    </Dialog>
  );
};
